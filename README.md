# Blue-CRC

# Overview

The [Cyclic Redundancy Code(CRC)](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) is an error-detecting code commonly used in digital network and storage devices to detect accidental changes to digital data. The principle of CRC is that a small digest of original data, which is similar to what is generated by hash function, is calculated and appended to original data before transmission and in the receiving end CRC is calculated on the received data again and compared with appended digest to check consistency. The CRC calculation is widely used in many fields especially in the network transmission, the standard protocols likes TCP/IP or RDMA all require CRC calculations. With the development of network technology, the speed of transmission is improved greatly which also challenges the high-performance implementation of CRC. This repo  implements a highly parameterized, parallel, pipelined and high-throughput hardware of CRC calculation using [Bluespec System Verilog](https://github.com/B-Lang-org/bsc).

## Features

The main features of the implemented CRC IP are listed as follows:

- Complete CRC Configuration: The IP supports complete CRC configuration parameters including polynomial, initVal(the initial CRC value), finalXor(the result is xor’d with this value if desired), reflectData(if True, reverse the input bit order), reflectRemainder(if True, reverse the result bit order).
- Standard Interface: The input interface supports AxiStream protocol whose data width is parameterized. And the outputCRC result is guarded by the basic handshake protocol.
- Parallel: The IP is designed to process multi-byte input at the same cycle.
- Fully Pipelined: The IP takes in one AxiStream frame every cycle.
- High Throughput: The IP configured with 256-bit input and 32-bit CRC output can runs at 500MHz on Xilinx xcvu9p FPGA.

# Theory of Operation

## Algorithm Theory

The idea of our parallel and high-performance CRC implementation comes from the [paper](https://ieeexplore.ieee.org/abstract/document/5501903) and its corresponding [open-source implementation](https://bitbucket.org/spandeygit/crc32_verilog). And main contributions of this repo compared to the existing work include:

- Parameterize the original design and provide a standard interface;
- Refine the logic implementation to improve the timing issue;

The calculation of CRC of original data is basically a division operation on two polynomials based on modulo-2 arithmetic and the remainder of this division is just the checksum we wanted. Consider a m-bit original data $b_{m-1}b_{m-2}b_{m-3}...b_{1}b_{0}$ can be represented as the polynomial M(x):

$$
M(x)=b_{m-1}x^{m-1}+b_{m-2}x^{m-2}+...+b_{1}x+b_{0}
$$

And a predetermined (n+1)-bit generator polynomial can be represented as G(x):

$$
G(x)=b_{n}x^{n}+b_{n-1}x^{n-1}+...+b_{1}x^{1}+b_{0}
$$

And the CRC is derived following the equation below:

$$
CRC=remainder(\frac{M(x)x^{n}}{G(x)})
$$

And more detailed introduction of CRC can be accessed through this [link](https://en.wikipedia.org/wiki/Cyclic_redundancy_check). Based on the characteristics of modulo-2 arithmetic, CRC calculation can be easily implemented using a LFSR register as the figure shown below:


<div align=center><img src="./img/lfsr.png"></div>
However, the LFSR implementation takes only one-bit per cycle, which only provides a poor throughput. In order to get a parallel and high-performance CRC design, the serial implementation demonstrated above should be rearranged into a parallel configuration. And the following two theorems is used to achieve parallelism in CRC computation.

- Theorem 1:

$$
CRC[A(x)]=CRC(\sum_{i=1}^{n}A_{i})=\sum_{i=1}^{n}CRC(A_{i})
$$

- Theorem 2:

$$
CRC[x^kA(x)] = CRC[x^kCRC[A(x)]]
$$

Theorem 1 indicates that original data of any length can be split into multiple pieces and CRC calculation of each piece can be performed parallel and then combined to get complete CRC result of original data. In our designed, the length of a piece is 8-bit and it’s assumed that the length of original data is multiples of bytes. For example, a N-bit original data, represented as polynomial $A(x)$, can be divided into n bytes, i.e. $N=8\times n$, each byte of original data is represented as the polynomial $A_{i}(x)$, and $A(x)$ can be expressed as:

$$
A(x)=\sum_{i=0}^{n}A_i(x)\ x^{8i}
$$

And the CRC of A(x) is derived as below:

 

$$
CRC(A(x))=CRC(A_{n-1}(x)x^{8(n-1)}+CRC(A_{n-2}x^{8(n-2)}))+... +CRC(A_{1}(x)x^8)+ CRC(A_{0}(x))
$$

To calculate the CRC of each 8-bit piece, we can first compute the CRC results of all possible 8-bit input data and store them  in a lookup table. When we need to compute CRC of a specific input, we can just search the precomputed table using the input data as index.

However, the parallel scheme proposed above is still impractical for hardware implementation. The length of original data is random and the hardware only supports fixed data width. What’s more, the length of input data is usually very large, especially for network application, and the required hardware resource grows with data length linearly. In hardware implementation, the width of input port of CRC component is usually fixed and original data is split into pieces of input port width and sent into the component serially. 

For example, the width of input port is fixed at 256 and original data is divided into pieces of 256-bit and sent into component in big-endian, i.e., high-bits are transmitted first. So the hardware needs to compute the CRC result in a iterative manner. In each iteration, component calculates the 256-bit input each cycle based on Theorem 1, and then combined with the CRC results of former bits, and finally the combined result is stored in registers for the next iteration. The combine of CRC of current input with that of former bits is based on Theorem 2. Take the first two iterations as example, the first iteration computes the CRC of first 256-bits of original data $CRC(A_{n-1}(x))$ and in the second iteration, the CRC of second 256-bits of original data $CRC(A_{n-2}(x))$ is computed first and then this two CRC is combined to get CRC of first 512-bits based on the equation below:

$$
CRC[A_{n-1}(x)x^{256}+CRC(A_{n-2}(x))]=CRC[x^{256}CRC(A_{n-1}(x))]+CRC[A_{n-2}(x)]
$$

Following the equation above, in the second iteration, the $CRC(A_{n-1}(x))$ got in the former iteration is multiplied by $x^{256}$ and then perform CRC calculation again before combined with the CRC of this iteration. This calculation can also be done using lookup table based on Theorem1.

## Block Diagram

Based on the parallel scheme proposed above, a simplified pipelined hardware architecture used in our design is shown in the figure below:

<div align=center><img src="./img/blockdiagram.png" width="55%"></div>

The main problem of this pipelined architecture is that it assumes that the length of original data just be multiples of input port width. But in real applications, this assumption is impractical especially for large port width like 256-bits and 512-bits. So additional data and control path is needed to handle this unalignment case. And our design has added this handling logic and supports calculating the CRC of original data with any length. The theory and corresponding structure to resolve unalignment case will be added to this document in the near future.

## Parameters

The following table lists the instantiation parameters of our CRC IP.

| Parameter Name | Type | Description | Requirement |
| --- | --- | --- | --- |
| crcWidth | numeric type | The bit width of crc result | The crcWidth needs to be a multiple of 8 |
| polynomial | Bit#(crcWidth) | The value of generator polynomial | The value should be in the range of crcWidth-bit data |
| initVal | Bit#(crcWidth) | The initial value of crc | The value should be in the range of crcWidth-bit data |
| finalXor | Bit#(crcWidth) | The final result is xor’d with this value  | The value should be in the range of crcWidth-bit data |
| reflectData | Bool | if True, reverse the bit order of each byte of input data | / |
| relectRemainder | Bool | if True, reverse the bit order of whole final result | / |
| dataWidth | numeric type | The bit width of input data | The dataWidth needs to be a multiple of 8 |
| dataByteNum | numeric type | The width of tkeep field in AxiStream | The dataByteNum equals to dataWidth/8 |

## Hardware Interface

 The hardware design of this repo is implemented in Bluespec System Verilog. BSV ***module*** interacts with each other through ***interface*** which consists of subinterfaces or ***method***. The ***interface*** designed for our IP is named **CrcAxiStream** and consists of two subinterface:

| Name | Type | Descriptions |
| --- | --- | --- |
| axiStreamIn | Put#( AxiStream#(dataByteNum, dataWidth) ) | The Put interface includes a method which takes in a struct of AxiStream type and returns Action. |
| crcResultOut | Get#(Bit#(crcWidth)) | The Get interface includes a method which returns ActionValue#(Bit#(crcWidth)). |

The fields of AxiStream struct in BSV are listed below:

| Name | Type |
| --- | --- |
| tData | Bit#(dataWidth) |
| tKeep | Bit#(tKeep) |
| tLast | Bool |
| tUser | Bool |

Besides, the BSV implementation can also generate Verilog codes and all interface signals are listed as below:

| Name | Direction | Type |
| --- | --- | --- |
| CLK | In | wire |
| RST_N | In | wire |
| s_axi_stream_tvalid | In | wire |
| s_axi_stream_tready | Out | wire |
| s_axi_stream_tlast | In | wire |
| s_axi_stream_tuser | In | wire |
| s_axi_stream_tdata | In | wire [DATA_WIDTH - 1 : 0] |
| s_axi_stream_tkeep | In | wire [KEEP_WIDTH - 1 : 0] |
| m_crc_stream_valid | Out | wire |
| m_crc_stream_ready | In | wire |
| m_crc_stream_data | Out | wire [CRC_WIDTH - 1 : 0] |

## Input Format

The CRC IP supports calculating CRC of original data consisting of arbitrary number of bytes. The original data is divided into small pieces of same size first and then the pieces are transmitted to the CRC component serially. Note that the data should be transmitted in the **big-endian** order, which means that data pieces of more significant bits are transmitted first and in a AxiStream transaction the most significant byte is placed in the lowest 8-bit of tData field. The figure below shows the example of transmitting 10-bytes original data and the width of tData is configured at 32-bit. Note that if the length of data is not a multiple of the width of tData, the bits in  tKeep corresponds to null bytes should be clear.

<div align=center><img src="./img/transaction.png" width="65%"></div>

# Area Usage and Frequency

The area usage and frequency of our CRC IP are highly related to the settings of parameters, especially signal width parameters including ***dataWidth*** and ***crcWidth.*** In general, the area usage increases and the timing issue worsens as the value of these two parameters increase.

In this repo, CRC modules under 12 different configurations are instantiated and then synthesized and implemented based on Xilinx **xcvu9p** device using **Vivado**. The area usage and timing are shown in tables below.

- Timing Report: The CRC instantiations are synthesized and implemented using Vivado under the timing constraint of 500Hz and the setup time slacks after routing are listed below:

| dataWidth | crcWidth | Setup Slack |
| --- | --- | --- |
| 64 | 8 | 0.190 ns |
| 128 | 8 | 0.218 ns |
| 256 | 8 | 0.098 ns |
| 512 | 8 | 0.093 ns |
| 64 | 16 | 0.320 ns |
| 128 | 16 | 0.132 ns |
| 256 | 16 | 0.140 ns |
| 512 | 16 | 0.078 ns |
| 64 | 32 | 0.112 ns |
| 128 | 32 | 0.124 ns |
| 256 | 32 | 0.001 ns |
| 512 | 32 | -0.410 ns |
- Area Usage:

The detailed area usage under 3 different configurations are shown as follows:

```verilog
------------
8-bit crcWidth and 256-bit dataWidth:
------------
CLB Logic
+----------------------------+------+-------+------------+-----------+-------+
|          Site Type         | Used | Fixed | Prohibited | Available | Util% |
+----------------------------+------+-------+------------+-----------+-------+
| CLB LUTs                   | 6651 |     0 |          0 |   1182240 |  0.56 |
|   LUT as Logic             | 4067 |     0 |          0 |   1182240 |  0.34 |
|   LUT as Memory            | 2584 |     0 |          0 |    591840 |  0.44 |
|     LUT as Distributed RAM | 2584 |     0 |            |           |       |
|     LUT as Shift Register  |    0 |     0 |            |           |       |
| CLB Registers              | 3433 |     0 |          0 |   2364480 |  0.15 |
|   Register as Flip Flop    | 3433 |     0 |          0 |   2364480 |  0.15 |
|   Register as Latch        |    0 |     0 |          0 |   2364480 |  0.00 |
| CARRY8                     |    0 |     0 |          0 |    147780 |  0.00 |
| F7 Muxes                   |    0 |     0 |          0 |    591120 |  0.00 |
| F8 Muxes                   |    0 |     0 |          0 |    295560 |  0.00 |
| F9 Muxes                   |    0 |     0 |          0 |    147780 |  0.00 |
+----------------------------+------+-------+------------+-----------+-------+
BLOCKRAM
+----------------+------+-------+------------+-----------+-------+
|    Site Type   | Used | Fixed | Prohibited | Available | Util% |
+----------------+------+-------+------------+-----------+-------+
| Block RAM Tile |    0 |     0 |          0 |      2160 |  0.00 |
|   RAMB36/FIFO* |    0 |     0 |          0 |      2160 |  0.00 |
|   RAMB18       |    0 |     0 |          0 |      4320 |  0.00 |
| URAM           |    0 |     0 |          0 |       960 |  0.00 |
+----------------+------+-------+------------+-----------+-------+

------------
16-bit crcWidth and 256-bit dataWidth:
------------
**CLB Logic
+----------------------------+------+-------+------------+-----------+-------+
|          Site Type         | Used | Fixed | Prohibited | Available | Util% |
+----------------------------+------+-------+------------+-----------+-------+
| CLB LUTs                   | 9556 |     0 |          0 |   1182240 |  0.81 |
|   LUT as Logic             | 5024 |     0 |          0 |   1182240 |  0.42 |
|   LUT as Memory            | 4532 |     0 |          0 |    591840 |  0.77 |
|     LUT as Distributed RAM | 4532 |     0 |            |           |       |
|     LUT as Shift Register  |    0 |     0 |            |           |       |
| CLB Registers              | 3720 |     0 |          0 |   2364480 |  0.16 |
|   Register as Flip Flop    | 3720 |     0 |          0 |   2364480 |  0.16 |
|   Register as Latch        |    0 |     0 |          0 |   2364480 |  0.00 |
| CARRY8                     |    0 |     0 |          0 |    147780 |  0.00 |
| F7 Muxes                   |    0 |     0 |          0 |    591120 |  0.00 |
| F8 Muxes                   |    0 |     0 |          0 |    295560 |  0.00 |
| F9 Muxes                   |    0 |     0 |          0 |    147780 |  0.00 |
+----------------------------+------+-------+------------+-----------+-------+
BLOCKRAM
+----------------+------+-------+------------+-----------+-------+
|    Site Type   | Used | Fixed | Prohibited | Available | Util% |
+----------------+------+-------+------------+-----------+-------+
| Block RAM Tile |    0 |     0 |          0 |      2160 |  0.00 |
|   RAMB36/FIFO* |    0 |     0 |          0 |      2160 |  0.00 |
|   RAMB18       |    0 |     0 |          0 |      4320 |  0.00 |
| URAM           |    0 |     0 |          0 |       960 |  0.00 |
+----------------+------+-------+------------+-----------+-------+**

------------
32-bit crcWidth and 256-bit dataWidth:
------------
CLB Logic
+----------------------------+-------+-------+------------+-----------+-------+
|          Site Type         |  Used | Fixed | Prohibited | Available | Util% |
+----------------------------+-------+-------+------------+-----------+-------+
| CLB LUTs                   | 20508 |     0 |          0 |   1182240 |  1.73 |
|   LUT as Logic             |  9708 |     0 |          0 |   1182240 |  0.82 |
|   LUT as Memory            | 10800 |     0 |          0 |    591840 |  1.82 |
|     LUT as Distributed RAM | 10800 |     0 |            |           |       |
|     LUT as Shift Register  |     0 |     0 |            |           |       |
| CLB Registers              |  8494 |     0 |          0 |   2364480 |  0.36 |
|   Register as Flip Flop    |  8494 |     0 |          0 |   2364480 |  0.36 |
|   Register as Latch        |     0 |     0 |          0 |   2364480 |  0.00 |
| CARRY8                     |     0 |     0 |          0 |    147780 |  0.00 |
| F7 Muxes                   |     0 |     0 |          0 |    591120 |  0.00 |
| F8 Muxes                   |     0 |     0 |          0 |    295560 |  0.00 |
| F9 Muxes                   |     0 |     0 |          0 |    147780 |  0.00 |
+----------------------------+-------+-------+------------+-----------+-------+
BLOCKRAM
+----------------+------+-------+------------+-----------+-------+
|    Site Type   | Used | Fixed | Prohibited | Available | Util% |
+----------------+------+-------+------------+-----------+-------+
| Block RAM Tile |    0 |     0 |          0 |      2160 |  0.00 |
|   RAMB36/FIFO* |    0 |     0 |          0 |      2160 |  0.00 |
|   RAMB18       |    0 |     0 |          0 |      4320 |  0.00 |
| URAM           |    0 |     0 |          0 |       960 |  0.00 |
+----------------+------+-------+------------+-----------+-------+
```
# User Interface
For BSV users, you can import our packages directly and instantiate CrcAxiStream interface in your codes. And for Verilog users, we also provide a script in [scripts/CrcGenerator.py](./scripts/CrcGenerator.py) to generate custom Verilog module automatically. In the header of this script, you can specify parameters of the custom CRC hardware you need and then run the script in the root directory by:
```
python3 scripts/CrcGenerator.py
```
The generated files containing Verilog modules and contents of used lookup tables are located in the [gen/](./gen/) directory. It shound be noted that you need to install [bluespec compiler](https://github.com/B-Lang-org/bsc/releases) before running the scripts to generate Verilog files.
# Further Work

- Refine timing violation under the configuration of 512-bit dataWidth and 32-bit crcWidth.
- Complete documentation in algorithm theory part.